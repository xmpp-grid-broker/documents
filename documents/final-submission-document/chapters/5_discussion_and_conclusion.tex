% !TeX spellcheck = en_GB
\chapter{Discussion and Conclusion}
\epigraph{Wisdom is not a product of schooling but of the lifelong attempt to acquire it.}{Albert Einstein}
\section{Achieved Result}

In this section, we describe the archived results during this thesis and how we managed to reach them.

\subsection{Implemented Requirements}

As listed in Table~\ref{tab:implemented-requirements}, we implemented 86\% of the overall requirements that we had planed to accomplish. The 5 missing requirements could not be implemented due to technical constrains, which is discussed in depth in Section~\fullref{encountered-problems}.

During the course of the project, we implemented two optional requirements.

\begin{table}[H]
    \begin{tabu}{X l}
        \toprule
        Requirement Group
        & implemented\\
        % & comment
        \midrule

        \fullref{sec:authentication}
        & \textit{partial (4/7)} \\
        %& Missing: "Multiple Administrators", "Audit Trail" and "Logout"\\

        \fullref{sec:list-topics}
        & \textit{partial (5/6)}\\
        % & without name filter and  optional features ("Limited Access")\\

        \fullref{sec:create-topic}
        & \textit{complete (1/1)}\\
        % & \\

        \fullref{sec:create-collection}
        & \textit{complete (3/3)}\\
        % & Without initial Consumers and Providers\\

        \fullref{sec:delete-topic}
        & \textit{complete (1/1)}\\
        % & \\

        \fullref{sec:delete-collection}
        & \textit{complete (3/3)}\\
        % & \\

        \fullref{sec:manage-subscriptions}
        & \textit{complete (5/5)}\\
        % & \\

        \fullref{sec:manage-affiliations}
        & \textit{complete (4/4)}\\
        % & \\

        \fullref{sec:manage-persisted-items}
        & \textit{partial (4/5)}\\
        % & Without filtering and "Delete Set of Persisted Item From a Topic"\\

        \fullref{sec:subscription-requests}
        & \textit{not implemented}\\
        % & \\

        \fullref{sec:validate-controller-config}
        & \textit{complete (2/2)}\\
        % & \\

        % \midrule
        \textbf{Total}
        & 32/37 $\approx 86\%$ \\
        % % & \\

    \end{tabu}
    \caption{Fulfilled requirements by groups}
    \label{tab:implemented-requirements}
\end{table}


\subsection{Architecture}

\subsubsection{Performance}
% TODO: Run tests?
Due to our chosen architecture style (see Chapter~\fullref{sec:architecture}),
the main performance concern of \gls{xmpp-grid} administrators lies with the \gls{xmpp} server.

Our implementation uses the most efficient, parallel way to query the \gls{xmpp} server.
However, due to limitations of the \gls{xmpp} protocol, it was not possible to implement all requirements in an efficient way.
More details on these limitations can be found in Section~\fullref{encountered-problems}.

\subsubsection{Concurrency and Scalability}
As our application is implemented to run in a web browser and holds no permanent state, it is very well suited for concurrency.

The primary concern regarding scalability in a \gls{xmpp-grid} is the performance of the underlying \gls{xmpp} server, which was not part of this thesis.


\subsubsection{Usability}
During the course of our project we implemented several usability features in the application.
A prominent example of this are the so called bread-crumbs, which allow fast and direct navigation trough different application levels.

We regret that it was not possible to conduct a usability test with a typical user during the thesis.

\subsubsection{Security}
In a expert review of our architecture, a good security level was attested.

To prevent risks due to misconfiguration or missing features of the \gls{xmpp} server or reverse proxy, we provide additional documentation alongside the application, which contains recommendations for administrators\footnote{More details on this can be found in Section~\ref{sec:security-risk-mitigation} and `docs' folder in the source code repository.}.

\subsubsection{Architectural Decisions}
In this Section, we reflect on our \nameref{sec:architectural-decisions} and how they turned out.

\paragraph{Architecture Style}
Due to limitations in the \gls{xmpp} standard, features like autocomplete and filtering could not be implemented.
This would have been easier with a server plug-in, but coupled the client to a specific XMPP server.

\paragraph{Platform}
The implementation of a web application proved as portable and flexible as we had hoped for.

\paragraph{SASL Authentication Strategy}
%    - SASL EXTERNAL mit Websockets / client certificate -> would be easier with username/pw -> In practice you need proxy, because popup; link to problems
The use of SASL EXTERNAL proved to be suboptimal.
We discovered, that due to policies in current web browsers nearly always a reverse-proxy is required with our implementation, as the \gls{xmpp} WebSocket or \gls{bosh} must be reachable under a already authenticated TLS endpoint.

In hindsight, to use SASL SCRAM would probably have eased the development and deployment of the application.

More details on this issue can be found in Section~\ref{sec:limitations-of-requirement-multiple-administrators}.

\paragraph{Role Management}
We think, that the decision to use Collection Nodes as role management makes sense.
However, we were not able to verify this functionality, as the openfire \gls{xmpp} server used in our development setup has not implemented Collection Nodes according to the newest standard version \gls{publish-subscribe} \gls{xep} \cite{xep-0248}.

\paragraph{Webapplication Communication Topology}
In general, using XMPP directly from the web browser worked relatively well.
However, due to limitations in the openfire \gls{xmpp} server implementation and SASL EXTERNAL, we had to use BOSH and a HTTP proxy in front of the \gls{xmpp} server. See Section~\fullref{encountered-problems} for more details on this topic.

\paragraph{Frontend Framework}
The decision to use Angular with TypeScript and IDEA has turned out to be very efficient and clean solution.

\paragraph{UI Library}
We think that the decision for the spectre.css library provided us with a good compromise in terms of productivity and visual results. Also, it is very well suited for the long life cycle of the application.

\paragraph{Frontend Structure}
To split the application into multiple modules was the right choice.
However, we had to slightly modify the initial layering and design during the course of the project.

\paragraph{XMPP Client Library}
The Stanza.io \gls{xmpp} library worked well in our application.
We did not largely rely on the abstraction API of Stanza, as we required many advanced \gls{publish-subscribe} features.
We opened two Pull Requests with error corrections on the Stanza Github page\footnote{See \url{https://github.com/otalk/jxt-xmpp/pull/23} and \url{https://github.com/legastero/stanza.io/pull/264}},
which were quickly merged and released.

\subsection{Implementation}
% TODO: - tests: coverage etc. (see redbackup); how many lines tests/lines code ratio
% TODO: - Ausgew√§hlte Implementierungsdetails/Metriken diskutieren (Bsp. Algorithmen, Datenstrukturen, Libraries, Architectural Hot Spots)


\section{Lessons Learned}
% - Documentation: Difficult to summarise standards;
% - Compodoc documentation tool was not a grand help - probably better suited for library/widget providers
% - We tried to systematically document arch. decisions, how did that turned out?
%   - Good, and helps to think about decisions; helps for structured planning
%   - We could have done more such decisions later in the project (structure in the modules; barrel imports etc.)
% + Docker Development environment and automation was very helpful in terms of production and portability for developers.
% - It paid off, writing many tests - but TDD sadly not possible with angular and stanza (api was not easy to mock - no TS types).

% - Project management
%   - Issue management good in general (JIRA)
%       - some issues with time estimates due to too large issues https://project.redbackup.org/browse/XGB-47 https://project.redbackup.org/browse/XGB-46
%       - We should have better specified tasks and created more and better todo lists
%       - difficult to estimate because we did not know a) Angular b) XMPP c) XMPP-Grids beforehand
%   + CI Setup / GitHub Reviews / Deployment project website


% -----
% - XMPP Standards with standard versions is BAD (e.g. split of pubsub nodes/collection)
% - XEPs are very interlinked and not all standards are actively extended (e.g. rely on deprecated standards)
% - XEPs are very much OPTIONAL or MAY - you can rely on nearly no features; many can not be queried feature discovery. XEPs have no comprehensive specified e.g. error cases.

% - XMPP-Grid standard uses different terminology than xmpp standards - somtimes overlaping terms. This makes it very difficult to comprehend it.


\section{Future work}
The result of our bachelor thesis is a working application, ready to prove itself in practice.
Even though all specified functionality was implemented, the user experience can still be further improved.

Conducting usability tests by observing administrators who manage \glspl{xmpp-grid} can reveal significant insights~\cite{krug:dont-make-me-think}.

To further improve the user experience, auto-complete for users and topics might be helpful.
As already discussed in Section~\fullref{encountered-problems}, this cannot be implemented efficiently due to shortcomings in the \gls{publish-subscribe} \gls{xep}.
One option would be to get involved and propose the required functionality in the \gls{xep} standardisation process.
A more short-term solution would be to tie the implementation closer to a specific \gls{xmpp} server that supports these features over proprietary APIs.
Alternatively, an unofficial \gls{xep} including corresponding server plugins can be specified and implemented.

Working around shortcomings of the \gls{xmpp} server implementations, lost updates for example (See Section~\fullref{sec:lost-updates}), could advance the usability as well.
However, It must be noted that adding more logic in the client contradicts the \gls{xmpp} philosophy that encourages simple client and complex server implementations \cite{definitive-guide-xmpp}.

\section{Conclusion}
\paragraph{The \gls{xmpp-grid} \gls{broker} application} enables administrators to configure \glspl{xmpp-grid} in a usable and productive way.
The modern web interface facilitates obtaining a comprehensive view of the configuration and structure of an \gls{xmpp-grid}.
Apart from improving the usability significantly, the application is also cross-platform and not tied to a particular \gls{xmpp} server implementation.

\paragraph{Our proposed architecture} has proven to work in practice.
Although the initial setup with a proxy server is not trivial, the architecture will pay off in practice regarding security and maintainability as reverse proxies are commonly used, and static sites are easy to maintain and upgrade.

\paragraph{Angular and stanza} turned out to be a good choice for the implementation.
Angular provides productive tools and a comprehensive testing infrastructure that allowed us to build an application that can be maintained efficiently in the long-term.

Stanza met most of our requirements concerning \gls{xmpp} support and allowed us to extend and improve it where needed.

Using Openfire as an \gls{xmpp} server backend was demanding at times due to the scanty implementation of the \gls{publish-subscribe} standard.
Some of these shortcomings, however, revealed problematic limitations of the standard which otherwise might not have been considered.

\paragraph{The Bachelor Thesis} went well from our point of view.
We were able to satisfy all critical requirements despite some limitations in the underlying standards and \gls{xmpp} server hindered our implementation.

\paragraph{In the future,} the application must prove itself in practice.
Based on feedback from users in the industry, the usability and feature set can further be refined.

To support some features efficiently, the implementation must either be bound to a specific \gls{xmpp} server or new extensions to the \gls{xmpp} standard must be proposed.

We hope that with the help of our implementation the IETF draft ``Using \gls{xmpp} for Security Information Exchange'' will become an established security standard used in practical industry applications.
